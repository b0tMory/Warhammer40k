<!DOCTYPE html>
<html lang="en">
<head>
    <title>Warhammer40k - Image</title>
    <meta charset="UTF-8">
    <style>
        html, body {
            margin: 0;
            padding: 0;
            background: transparent;
            overflow: hidden;
            height: 100%;
            width: 100%;
        }

        #image {
            width: 100vw;
            height: 100vh;
            object-fit: contain;
            display: block;
        }

        .map-container {
            position: relative;
            display: inline-block;
            width: 100%;
            height: 100%;
        }

        .map-image {
            display: block;
            max-width: 100%;
        }

        .marker {
            position: absolute;
            width: 20px;
            height: 20px;
            background: rgba(0, 255, 0, 0.6);
            border-radius: 50%;
            cursor: pointer;
            transform: translate(-50%, -50%);
        }

        .shape {
            position: absolute;
            width: 50px;
            height: 50px;
            transform: translate(-50%, -50%);
            cursor: move;
            z-index: 10;
        }

        .shape-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .shape-label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10px;
            font-weight: bold;
            color: white;
            text-shadow: 1px 1px 2px black;
            pointer-events: none;
            white-space: nowrap;
        }

        .controls {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border: 1px solid black;
            z-index: 100;
            border-radius: 5px;
        }

        .controls button {
            margin: 2px;
            padding: 5px 10px;
        }

        
    </style>
</head>
<body>
    <div class="map-container" id="mapContainer">
        <img id="image" src="http://localhost:5500/GW%20Layouts%202025-2026/GW%20-%20Crucible%20of%20Battle%20-%20Layout%202.png" alt="Test Image" style="width: 100%; height: 100%; object-fit: contain;">
    </div>

    <!-- Added missing UI elements -->
    <div class="status-info">
        <div>Units: <span id="unitCount">0</span></div>
        <div>Selected: <span id="selectedInfo">None</span></div>
    </div>

    <div id="checkboxContainer"></div>

    <script>
        // Existing checkbox data
        const checkboxData = {
            "GW - Tipping Point - Layout 4.png": ["Army 1", "Army 2", "Army 3"],
            "GW - Crucible of Battle - Layout 2.png": ["Alpha Squad", "Bravo Squad", "Charlie Squad"],
            "WTC - Search and Destroy - Layout 1.png": ["Unit A", "Unit B", "Unit C"],
            "WTC - Tipping Point - Layout 2.png": ["Unit X", "Unit Y", "Unit Z"]
        };

        // Shape management
        let shapeCounter = 0;
        let selectedShape = null;
        let shapes = [];

        // BroadcastChannel to receive messages from index.html
        const bc = new BroadcastChannel("overlay_channel");

        // Listen for messages from index.html
        bc.onmessage = function(event) {
            const data = event.data;
            console.log("Received broadcast:", data);
            
            if (data.imagePath && !data.action) {
                // Map image update
                updateImageFromBroadcast(data.imagePath);
            } else if (data.action === 'addUnit') {
                // Add unit
                addShapeFromBroadcast(data.imagePath, data.unitName, data.player, data.unitId);
            } else if (data.action === 'deleteUnit') {
                // Delete unit
                deleteShapeByName(data.unitName, data.player);
            } else if (data.action === 'rotateUnit') {
                // Rotate unit by specific ID only - enhanced logging and validation
                rotateUnitById(data.unitId, data.newRotation);
            }
        };

        function addShapeFromBroadcast(imagePath, unitName, player, unitId) {
            shapeCounter++;
            const shape = document.createElement('div');
            shape.className = 'shape';
            shape.style.top = '50%';
            shape.style.left = '50%';
            shape.dataset.id = shapeCounter;
            shape.dataset.rotation = '0';
            shape.dataset.unitName = unitName;
            shape.dataset.player = player;
            shape.dataset.unitId = unitId;  // This is the crucial unique identifier

            // Add the actual image
            const img = document.createElement('img');
            img.src = imagePath;
            img.className = 'shape-image';
            img.alt = unitName;
            shape.appendChild(img);

            const label = document.createElement('div');
            label.className = 'shape-label';
            label.textContent = unitName;
            shape.appendChild(label);

            // Improved click handler that doesn't interfere with dragging
            let clickStartTime;
            let clickStartPos;
            
            shape.addEventListener('mousedown', function(e) {
                clickStartTime = Date.now();
                clickStartPos = { x: e.clientX, y: e.clientY };
            });
            
            shape.addEventListener('mouseup', function(e) {
                const clickDuration = Date.now() - clickStartTime;
                const clickDistance = Math.sqrt(
                    Math.pow(e.clientX - clickStartPos.x, 2) + 
                    Math.pow(e.clientY - clickStartPos.y, 2)
                );
                
                // Only select if it was a short click without much movement (not a drag)
                if (clickDuration < 300 && clickDistance < 10) {
                    selectShape(shape);
                }
            });

            // Drag functionality
            makeDraggable(shape);

            document.getElementById('mapContainer').appendChild(shape);
            shapes.push(shape);
            selectShape(shape);

            updateUnitCount();
            console.log(`Added unit: ${unitName} for Player ${player} with unique ID ${unitId}`);
        }

        // Delete shape by unit name
        function deleteShapeByName(unitName, player) {
            const shapeToDelete = shapes.find(shape => 
                shape.dataset.unitName === unitName && 
                parseInt(shape.dataset.player) === player
            );
            
            if (shapeToDelete) {
                shapeToDelete.remove();
                shapes = shapes.filter(shape => shape !== shapeToDelete);
                
                // Clear selection if deleted shape was selected
                if (selectedShape === shapeToDelete) {
                    selectedShape = null;
                    const selectedInfo = document.getElementById('selectedInfo');
                    if (selectedInfo) selectedInfo.textContent = 'None';
                }
                
                updateUnitCount();
                console.log(`Deleted unit: ${unitName} for Player ${player}`);
            }
        }

        // Update unit count display
        function updateUnitCount() {
            const unitCountElement = document.getElementById('unitCount');
            if (unitCountElement) {
                unitCountElement.textContent = shapes.length;
            }
        }

        // Update image from broadcast
        function updateImageFromBroadcast(imagePath) {
            const img = document.getElementById("image");
            const cacheBusted = `${imagePath}?t=${Date.now()}`;
            img.src = cacheBusted;
            img.alt = `Map: ${imagePath}`;
            console.log("Map image updated:", cacheBusted);
            
            // Load checkboxes if needed
            const fileName = imagePath.split("/").pop();
            loadCheckboxesForMap(fileName);
        }

        // Select shape - improved with error checking
        function selectShape(shape) {
            // Remove selection from all shapes
            shapes.forEach(s => s.style.outline = 'none');
            
            // Select this shape
            selectedShape = shape;
            shape.style.outline = '3px solid yellow';
            
            // Update UI with error checking
            const selectedInfo = document.getElementById('selectedInfo');
            if (selectedInfo) {
                selectedInfo.textContent = `${shape.dataset.unitName} (Player ${shape.dataset.player}, ID: ${shape.dataset.unitId})`;
            }
            
            console.log(`Selected: ${shape.dataset.unitName} (Player ${shape.dataset.player}, Unique ID: ${shape.dataset.unitId})`);
        }

        // Add keyboard shortcut for deselection
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape' && selectedShape) {
                selectedShape.style.outline = 'none';
                selectedShape = null;
                const selectedInfo = document.getElementById('selectedInfo');
                if (selectedInfo) selectedInfo.textContent = 'None';
                console.log('Selection cleared');
            }
        });

        // Rotate a specific unit by its unique ID (from broadcast) - ENHANCED for individual rotation
        function rotateUnitById(unitId, newRotation) {
            console.log(`Attempting to rotate unit with ID: ${unitId} to ${newRotation}Â°`);
            
            // Find the EXACT unit by its unique ID (converted to string for comparison)
            const shape = shapes.find(s => s.dataset.unitId === String(unitId));
            
            if (shape) {
                // Update the rotation data
                shape.dataset.rotation = newRotation;
                
                // Apply the rotation transform while preserving position
                shape.style.transform = `translate(-50%, -50%) rotate(${newRotation}deg)`;
                
                console.log(`â Successfully rotated unit "${shape.dataset.unitName}" (ID: ${unitId}) to ${newRotation}Â°`);
                console.log(`Unit details - Name: ${shape.dataset.unitName}, Player: ${shape.dataset.player}, ID: ${shape.dataset.unitId}`);
            } else {
                console.warn(`â Could not find unit with ID: ${unitId}`);
                console.log("Available units:", shapes.map(s => ({
                    name: s.dataset.unitName,
                    player: s.dataset.player,
                    id: s.dataset.unitId
                })));
            }
        }

        // Make shape draggable - improved to not interfere with selection
        function makeDraggable(shape) {
            let isDragging = false;
            let hasMoved = false;
            let startX, startY, startLeft, startTop;

            shape.addEventListener('mousedown', function(e) {
                isDragging = true;
                hasMoved = false;
                startX = e.clientX;
                startY = e.clientY;
                
                const rect = shape.getBoundingClientRect();
                const containerRect = document.getElementById('mapContainer').getBoundingClientRect();
                
                startLeft = ((rect.left + rect.width/2 - containerRect.left) / containerRect.width) * 100;
                startTop = ((rect.top + rect.height/2 - containerRect.top) / containerRect.height) * 100;
                
                e.preventDefault();
            });

            document.addEventListener('mousemove', function(e) {
                if (!isDragging) return;
                
                const moveDistance = Math.sqrt(
                    Math.pow(e.clientX - startX, 2) + 
                    Math.pow(e.clientY - startY, 2)
                );
                
                if (moveDistance > 5) {
                    hasMoved = true;
                }
                
                const containerRect = document.getElementById('mapContainer').getBoundingClientRect();
                const deltaX = e.clientX - startX;
                const deltaY = e.clientY - startY;
                
                const newLeft = startLeft + (deltaX / containerRect.width) * 100;
                const newTop = startTop + (deltaY / containerRect.height) * 100;
                
                shape.style.left = newLeft + '%';
                shape.style.top = newTop + '%';
                
                // Preserve rotation when dragging
                const currentRotation = shape.dataset.rotation || '0';
                shape.style.transform = `translate(-50%, -50%) rotate(${currentRotation}deg)`;
            });

            document.addEventListener('mouseup', function() {
                if (isDragging && hasMoved) {
                    console.log(`Moved unit: ${shape.dataset.unitName} (ID: ${shape.dataset.unitId})`);
                }
                isDragging = false;
                hasMoved = false;
            });
        }

        // Existing functions
        function updateImageFromServer() {
            fetch("/current-image")
                .then(res => res.json())
                .then(data => {
                    const path = data.imagePath;
                    const img = document.getElementById("image");
                    if (path && img.src !== path) {
                        img.src = `${path}?t=${Date.now()}`;
                    }
                })
                .catch(err => {
                    // console.log("Server not available");
                });
        }

        setInterval(updateImageFromServer, 1000);

        const checkboxContainer = document.getElementById("checkboxContainer");

        function loadCheckboxesForMap(mapFileName) {
            checkboxContainer.innerHTML = "";

            if (checkboxData[mapFileName]) {
                checkboxData[mapFileName].forEach((labelText, index) => {
                    const checkboxId = `checkbox_${index}`;

                    const checkbox = document.createElement("input");
                    checkbox.type = "checkbox";
                    checkbox.id = checkboxId;
                    checkbox.checked = true;

                    const label = document.createElement("label");
                    label.htmlFor = checkboxId;
                    label.innerText = labelText;

                    checkboxContainer.appendChild(checkbox);
                    checkboxContainer.appendChild(label);
                    checkboxContainer.appendChild(document.createElement("br"));
                });
            }
        }

        function updateImageFromStorage() {
            const rawPath = localStorage.getItem("overlayImagePath");

            if (rawPath) {
                const fileName = rawPath.split("/").pop();
                const cacheBusted = `${rawPath}?t=${Date.now()}`;
                const img = document.getElementById("image");

                if (img.src !== cacheBusted) {
                    img.src = cacheBusted;
                    img.alt = `Overlay map: ${rawPath}`;
                    console.log("OBS overlay image updated:", cacheBusted);
                    loadCheckboxesForMap(fileName);
                }
            }
        }

        // Initial load
        updateImageFromStorage();
        setInterval(updateImageFromStorage, 1000);
        
        // Initialize unit count
        updateUnitCount();
    </script>
</body>
</html>